<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Quiz • PSC Guru</title>
<link rel="icon" href="data:,"/>
<style>
  :root{
    --bg:#eef7ef; --card:#ffffff; --ink:#113018; --muted:#5f7d67; --accent:#2f8f5b;
    --ring: rgba(47,143,91,.28); --danger:#c95757; --good:#2f8f5b;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);font:16px/1.45 system-ui,Segoe UI,Roboto,Inter,Arial;color:var(--ink)}
  header{background:linear-gradient(#ecf6ee,#e7f2ea);border-bottom:1px solid #dfefe6}
  .bar{max-width:980px;margin:0 auto;padding:12px 16px;display:flex;align-items:center;justify-content:space-between;gap:12px}
  .brand{display:flex;gap:10px;align-items:center}
  .logo{width:36px;height:36px;border-radius:10px;background:#1f6d43;color:#fff;display:grid;place-items:center;font-weight:800}
  .title{line-height:1}
  .title b{display:block}
  .title small{display:block;color:var(--muted);font-size:12px}
  .nav{display:flex;gap:8px}
  .chip{padding:6px 12px;border-radius:999px;background:#fff;box-shadow:0 1px 0 #0001;color:var(--ink);text-decoration:none}
  .timer{font-weight:700;color:#0a5}
  main{max-width:980px;margin:18px auto;padding:0 16px}
  h1{font-size:22px;margin:2px 0 10px}
  .meta{display:flex;align-items:center;gap:16px;color:var(--muted);font-size:13px;margin-bottom:8px}
  .card{background:var(--card);border-radius:14px;box-shadow:0 8px 24px #00000008,0 1px 0 #00000008;padding:16px}
  .qidx{color:var(--muted);font-weight:600;font-size:13px}
  .qtext{font-size:18px;margin:6px 0 14px}
  .opts{display:grid;gap:10px}
  .opt{padding:12px;border:1px solid #e3efe7;border-radius:12px;background:#fbfdfc;cursor:pointer;transition:.15s}
  .opt:hover{border-color:#bfe5cc;box-shadow:0 0 0 3px var(--ring)}
  .opt.correct{border-color:var(--good);background:#ecf9f2}
  .opt.wrong{border-color:var(--danger);background:#ffefef}
  .opt.lock{pointer-events:none;opacity:.95}
  .answer{display:none;margin:12px 0 4px;color:#075}
  .notice{background:#fff5e8;color:#7b4b00;border:1px solid #ffd9a6;padding:10px;border-radius:10px;margin:10px 0}
  .navrow{display:flex;gap:10px;justify-content:center;margin:10px auto 0}
  .btn{border:0;border-radius:999px;background:var(--accent);color:#fff;padding:8px 14px;font-weight:600;cursor:pointer}
  .btn.secondary{background:#e9f5ee;color:#155634}
  .btn:focus{outline:2px solid var(--ring)}
  .summary{margin:14px 0}
  .summary details{border:1px solid #e3efe7;background:#fff;border-radius:12px;padding:10px;margin-top:8px}
  .muted{color:var(--muted)}
</style>
</head>
<body>
<header>
  <div class="bar">
    <div class="brand">
      <div class="logo">PSC</div>
      <div class="title"><b>PSC Guru</b><small>Kerala PSC Exam Prep</small></div>
    </div>
    <div class="nav">
      <a class="chip" href="index.html">Home</a>
      <a class="chip" href="quiz.html">Quiz</a>
      <span id="hdrTimer" class="chip timer" style="display:none"></span>
    </div>
  </div>
</header>

<main>
  <h1 id="title">Quiz</h1>
  <div class="meta"><div id="metaCat"></div></div>

  <div id="alert" class="notice" style="display:none"></div>

  <div id="qwrap" class="card" style="display:none">
    <div class="qidx" id="qidx"></div>
    <div class="qtext" id="qtext"></div>
    <div id="opts" class="opts"></div>
    <div id="answer" class="answer"></div>
  </div>

  <div class="navrow" id="navrow" style="display:none">
    <button id="prevBtn" class="btn secondary">← Prev</button>
    <button id="showBtn" class="btn secondary">Show Answer</button>
    <button id="nextBtn" class="btn">Next →</button>
  </div>

  <section id="summary" class="summary" style="display:none"></section>
</main>

<script>
/* ====== CONFIG ====== */
const GS_SHEET_ID = "16iIOLKAkFzXD1ja7v6b7_ZUKVjbcsswX8LfJ_D0S57o";
const CATEGORIES_TAB = "Categories";

/* ====== helpers ====== */
const $ = s=>document.querySelector(s);
function csvToRows(text){
  const rows=[], row=[], pushRow=()=>{rows.push([...row]);row.length=0};
  let s="", q=false;
  for(let i=0;i<text.length;i++){
    const c=text[i], n=text[i+1];
    if(q){ if(c=='"' && n=='"'){s+='"';i++;} else if(c=='"'){q=false;} else s+=c; }
    else { if(c=='"') q=true; else if(c==','){ row.push(s.trim()); s=""; }
      else if(c=='\n'){ row.push(s.trim()); s=""; if(row.some(x=>x!=='')) pushRow(); }
      else s+=c; }
  }
  if(s.length||row.length){ row.push(s.trim()); if(row.some(x=>x!=='')) rows.push(row); }
  return rows;
}
function normalizeHeader(h){return (h||"").toLowerCase().replace(/\s+/g,'').replace(/[^a-z0-9_]/g,'');}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
async function fetchCSV(sheetName){
  const tries = [
    `https://docs.google.com/spreadsheets/d/${GS_SHEET_ID}/pub?output=csv&sheet=${encodeURIComponent(sheetName)}`,
    `https://docs.google.com/spreadsheets/d/${GS_SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheetName)}`,
    `https://docs.google.com/spreadsheets/d/${GS_SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(sheetName)}`
  ];
  for(let i=0;i<tries.length;i++){
    try{
      const res = await fetch(tries[i], {mode:"cors"});
      if(!res.ok) throw new Error(res.status+" "+res.statusText);
      const txt = await res.text();
      if(tries[i].includes("out:json")){
        const payload = JSON.parse(txt.replace(/^[\s\S]*?setResponse\(/,'').replace(/\);?$/,''));
        const table = payload.table;
        const headers = table.cols.map(c => normalizeHeader(c.label||c.id||""));
        const rows = table.rows.map(r => headers.map((_,j)=>(r.c[j]?.v ?? "").toString().trim()));
        return {headers, rows};
      }else{
        const rows = csvToRows(txt);
        const headers = rows.shift().map(normalizeHeader);
        return {headers, rows};
      }
    }catch(e){ if(i===tries.length-1) throw e; }
  }
}

/* ====== parsers ====== */
function firstNonEmpty(obj, names){
  for(const n of names){ if(obj[n]!=null && obj[n]!=="") return obj[n]; }
  return "";
}
function parseMCQ(headers, rows){
  const H = Object.fromEntries(headers.map((h,i)=>[h,i]));
  const optCols = ["opta","optb","optc","optd","opt1","opt2","opt3","opt4"].filter(x=>H[x]!=null);
  const correctCols = ["correct","answer","ans","key","answerkey","right","correctoption","solution","correctindex","ansindex"];

  return rows.map(r=>{
    const get = h => r[H[h]] ?? "";
    const q = get("question") || get("q") || r[0] || "";
    if(!q) return null;

    // collect options (A,B,C,D order as found)
    const options = optCols.map(h => (get(h)||"").toString().trim()).filter(Boolean);

    // read "correct" raw
    let rawCorrect = firstNonEmpty(Object.fromEntries(correctCols.map(c=>[c, get(c)])), correctCols).toString().trim();

    // find correct index or text robustly
    let correctIndex = -1;
    let correctText = "";

    // If raw is a letter A-D
    const letter = rawCorrect.match(/^[abcd]$/i);
    if(letter){ correctIndex = "abcd".indexOf(letter[0].toLowerCase()); }

    // Or if raw is 1-4
    const num = rawCorrect.match(/^[1-4]$/);
    if(num){ correctIndex = parseInt(num[0],10)-1; }

    // If still not found, try exact text match
    if(correctIndex<0 && options.length){
      const idx = options.findIndex(o => o.trim() === rawCorrect.trim());
      if(idx>=0) correctIndex = idx;
    }

    // Fallback: if an "answer" cell contains the full text and matches options
    if(correctIndex<0 && options.length){
      const ansText = (get("answer") || "").toString().trim();
      const idx = options.findIndex(o => o.trim() === ansText);
      if(idx>=0){ correctIndex = idx; rawCorrect = ansText; }
    }

    // Last fallback: if nothing matched, assume first option is correct (prevents null)
    if(correctIndex<0) correctIndex = 0;

    correctText = options.length ? options[correctIndex] : (rawCorrect || "");

    // If no explicit options, fall back to pure Q/A style
    if(options.length===0){
      const ans = (get("answer") || rawCorrect || "").toString().trim();
      return { q, options:[ans], correct:ans };
    }

    return { q, options, correct: correctText, correctIndex };
  }).filter(Boolean);
}
function fromQA(headers, rows){
  const H = Object.fromEntries(headers.map((h,i)=>[h,i]));
  return rows.map(r=>{
    const q = r[H.question] || r[0];
    const ans = (r[H.answer] || r[1] || "").toString().trim();
    return {q, options:[ans], correct: ans, correctIndex:0};
  }).filter(x=>x.q && x.correct);
}
async function loadQuestions(sheet){
  const {headers, rows} = await fetchCSV(sheet);
  const norm = headers.map(normalizeHeader);
  const hasOptions = norm.some(h=>/^opt[abcd1-4]$/.test(h));
  return (hasOptions ? parseMCQ(norm, rows) : fromQA(norm, rows));
}

/* ====== state ====== */
const url = new URL(location.href);
const sheetName = url.searchParams.get("sheet");
const wantRandom = url.searchParams.get("random");
const wantCount = parseInt(url.searchParams.get("count")||"",10) || null;
const timerSec = parseInt(url.searchParams.get("timer")||"",10) || null;

let questions = [];
let order = [];
let idx = 0;
let picked = new Map();
let optCache = new Map();
let startedAt = null, tickHandle=null;

/* ====== timer ====== */
function renderTimer(){
  if(!timerSec || !startedAt) return;
  const elapsed = Math.floor((Date.now()-startedAt)/1000);
  const left = Math.max(0, timerSec - elapsed);
  const mm = String(Math.floor(left/60)).padStart(2,'0');
  const ss = String(left%60).padStart(2,'0');
  const t = `${mm}:${ss}`;
  $("#hdrTimer").style.display = "";
  $("#hdrTimer").textContent = t;
  if(left===0){ clearInterval(tickHandle); showSummary(); }
}

/* ====== init ====== */
async function init(){
  if(wantRandom){
    const {headers, rows} = await fetchCSV(CATEGORIES_TAB);
    const H = Object.fromEntries(headers.map((h,i)=>[normalizeHeader(h),i]));
    const cats = rows.map(r=> r[H.sheet] || r[H.actualtabname] || r[1]).filter(Boolean);
    const chosen = cats[Math.floor(Math.random()*cats.length)];
    $("#metaCat").textContent = "Random • " + (chosen || "Unknown");
    questions = await loadQuestions(chosen);
  }else if(sheetName){
    $("#metaCat").textContent = sheetName;
    questions = await loadQuestions(sheetName);
  }else{
    $("#alert").style.display = "";
    $("#alert").textContent = "No category selected.";
    return;
  }

  if(!questions.length){
    $("#alert").style.display = "";
    $("#alert").textContent = "Failed to load this tab. Make sure the sheet is public (or Published to the web) and the tab name matches exactly.";
    return;
  }

  if(wantCount) questions = shuffle([...questions]).slice(0,wantCount);

  order = questions.map((_,i)=>i);
  showQuestion(0);

  startedAt = Date.now();
  if(timerSec){ tickHandle = setInterval(renderTimer, 300); renderTimer(); }
}

/* ====== rendering ====== */
function showQuestion(i){
  idx = Math.max(0, Math.min(order.length-1, i));
  const qIndex = order[idx];
  const q = questions[qIndex];

  $("#qwrap").style.display = "";
  $("#navrow").style.display = "";
  $("#qidx").textContent = `Question ${idx+1} / ${order.length}`;
  $("#qtext").textContent = q.q;

  let shuffled = optCache.get(qIndex);
  if(!shuffled){
    // Tag options with correctness using index if present
    shuffled = (q.options && q.options.length ? [...q.options] : [q.correct]).map((txt,ii)=>({
      txt,
      isCorrect: (typeof q.correctIndex === "number")
        ? (ii === q.correctIndex)
        : (txt.toString().trim() === (q.correct||"").toString().trim())
    }));
    shuffled = shuffle(shuffled);
    optCache.set(qIndex, shuffled);
  }

  const area = $("#opts"); area.innerHTML = "";
  shuffled.forEach(o=>{
    const div = document.createElement("div");
    div.className = "opt";
    div.textContent = o.txt;
    div.dataset.correct = o.isCorrect ? "1" : "0";   // <-- reliable tag
    div.onclick = ()=>{
      if(picked.has(qIndex)) return;
      const res = {picked:o.txt, isCorrect:o.isCorrect};
      picked.set(qIndex, res);
      const children = [...area.children];
      children.forEach(el => el.classList.add("lock"));
      if(res.isCorrect){
        div.classList.add("correct");
      }else{
        div.classList.add("wrong");
        const right = area.querySelector('.opt[data-correct="1"]');
        if(right) right.classList.add("correct");
      }
    };
    area.appendChild(div);
  });

  // restore if already answered
  const past = picked.get(qIndex);
  if(past){
    [...area.children].forEach(el=>{
      el.classList.add("lock");
      if(el.dataset.correct === "1") el.classList.add("correct");
      if(el.textContent.trim() === past.picked && past.isCorrect === false) el.classList.add("wrong");
    });
  }

  $("#answer").style.display = "none";
  $("#answer").textContent = "Answer: " + (q.correct || "");
}

/* ====== controls ====== */
$("#showBtn").onclick = ()=>{
  $("#answer").style.display = "";
  const area = $("#opts");
  const right = area.querySelector('.opt[data-correct="1"]');
  if(right){
    right.classList.add("correct");
    [...area.children].forEach(el => el.classList.add("lock"));
  }
};
$("#prevBtn").onclick = ()=> showQuestion(idx-1);
$("#nextBtn").onclick = ()=>{
  if(idx === order.length-1){ showSummary(); }
  else showQuestion(idx+1);
};

/* ====== summary ====== */
function showSummary(){
  clearInterval(tickHandle);
  $("#qwrap").style.display = "none";
  $("#navrow").style.display = "none";

  const total = order.length;
  let correct = 0;
  order.forEach(i=>{
    const res = picked.get(i);
    const q = questions[i];
    if(!res) return;
    const isOk = (typeof q.correctIndex==="number")
      ? (q.options.findIndex(t => t===res.picked) === q.correctIndex)
      : (res.picked.toString().trim() === (q.correct||"").toString().trim());
    if(isOk) correct++;
  });

  const s = $("#summary");
  s.style.display = "";
  s.innerHTML = `
    <div class="card">
      <h3>Summary</h3>
      <div class="muted">Score: <strong>${correct}</strong> / ${total}</div>
      ${timerSec ? `<div class="muted">Time: ${$("#hdrTimer").textContent}</div>` : ""}
      <details open style="margin-top:10px">
        <summary>Review answers</summary>
        ${order.map((i,k)=>{
          const q = questions[i];
          const res = picked.get(i) || {picked:"—", isCorrect:false};
          const ok = (typeof q.correctIndex==="number")
            ? (q.options.findIndex(t => t===res.picked) === q.correctIndex)
            : (res.picked.toString().trim() === (q.correct||"").toString().trim());
          return `
            <details>
              <summary><strong>${k+1}.</strong> ${q.q}</summary>
              <div class="muted">Your answer: <span style="color:${ok?'#0a5':'#b33'}">${res.picked}</span></div>
              <div class="muted">Correct: ${typeof q.correctIndex==="number" ? q.options[q.correctIndex] : (q.correct||"")}</div>
            </details>
          `;
        }).join("")}
      </details>
    </div>
  `;
}

/* boot */
init();
</script>
</body>
</html>
